# Устновка ОС и настройка

Официальный buildroot образ можно скачать из релизов в [GitHub репозитории](https://github.com/sipeed/LicheeRV-Nano-Build/releases). Я использовал версию [**20241021**](https://github.com/sipeed/LicheeRV-Nano-Build/releases/tag/20241021) *(все примеры также были протестированы на более свежей версии -* [***20250114***](https://github.com/sipeed/LicheeRV-Nano-Build/releases/tag/20250114)*)*.

Мы рекомендуем использовать нашу сборку 

Загрузка операционной системы происходит с SD карты. Записать на неё образ из под Linux’а можно с помощью **dd**:

```bash
xzcat "НАЗВАНИЕ.img.xz" | sudo dd of=/dev/sdX conv=sync status=progress
```

Если архив с образом распакован, то команда примерно такая же:

```bash
cat "НАЗВАНИЕ.img" | sudo dd of=/dev/sdX conv=sync status=progress
```

Вместо **/dev/sdX** подставляйте путь к вашей SD карте, она должна быть полностью отформатирована с таблицей разделов **MBR** (*msdos*), **без разделов** *(без файловой системы, только неразмеченное пространство)*.

На Windows можете использовать **Rufus** или **Balena Etcher**.

У меня плата с WiFi модулем, поэтому сразу после прошивки образа можно сконфигурировать данные для подключения к **WiFi сети**, чтобы подключаться по ssh *(он стартует автоматически)*.

Для этого примонтируйте раздел *rootfs* (после прошивки SD карты на ней будет два раздела: *boot* и *rootfs*) и отредактируйте файл **/etc/wpa\_supplicant.conf** следующим образом:

```bash
ctrl_interface=/var/run/wpa_supplicant
ap_scan=1
network={
  ssid="NAME"
  psk="PASSWORD"
}
```

Замените **NAME** и **PASSWORD** на данные от своей сети.

5G

WiFi трансивер на плате поддерживает сети 5G и антенна, идущая в комплекте (N2425D) двухдиапазонная, поэтому вы можете использовать плату с 5G WiFi сетью.

Теперь можно извлекать SD карту, вставлять её в одноплатник и подавать на него питание. Если всё сделано правильно, то на одноплатнике сначала загорятся оба светодиода *(красный - питание, синий - user)*, но затем синий светодиод начнёт мигать *(если запускать плату без SD карты или с некорректным образом системы, то синий светодиод будет постоянно светиться)*.

Чтобы найти устройство в локальной сети, можно воспользоваться **nmap** *(или любым другим сканером)*:

```bash
# поиск всех активных устройств в сети
sudo nmap -sN 192.168.1.0/24

# или сразу поиск по открытому 22 порту
nmap -sV -p 22 192.168.1.0/24
```

Теперь можно подключаться через ssh (по умолчанию имя пользователя и пароль - **root**).

```bash
ssh root@192.168.1.21
```

Если у вас плата без **Ethernet** или **WiFi**, то взаимодействовать с ней можно через отладочный **UART0**. Для этого подключите USB TTL переходник к пинам **A17** *(RX платы - TX переходника)*, **A16** *(TX платы - RX переходника)* и общую землю.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d75/508/d07/d75508d073cb0ead242c9ee851ab7634.png)

Далее через терминальную программу *(или screen на линуксе)* вы можете взаимодействовать с платой на скорости **115200** бод.

```bash
screen /dev/ttyUSB0 115200
```

Также имеется возможность работать с платой через **ACM** (*/dev/ttyACM0*) и локальную сеть поверх USB. Но для меня самыми удобными оказались **ssh** через **WiFi** и отладочный **UART0** *(в него плата посылает дополнительную отладочную информацию, которая иногда бывает полезна)*.

Плата имеет всего **256 Мб** оперативной памяти (из которых **128 Мб** занято под MIPI - CSI камеру и дисплей), чего может не хватать для некоторых задач. Решить эту проблему можно, добавив **swap**. Процесс можно перенести в **Buildroot**, чтобы итоговый образ уже был сконфигурирован с swap файлом, но самый простой способ - сделать его вручную, внутри работающей операционной системы. Все необходимые для этого утилиты идут из коробки в утилитах **BusyBox**:

```bash
fallocate -l 1G /swapfile # размер можете изменить на нужный вам
chmod 600 /swapfile
mkswap /swapfile
swapon /swapfile
```

Чтобы swap активировался автоматически после загрузки платы, необходимо добавить информацию о swap’е в **fstab**.

```bash
echo '/swapfile none swap sw 0 0' | tee -a /etc/fstab
```

Теперь после перезагрузки **swap** будет автоматически активироваться.

Далее в статье будут примеры программ, использующих библиотеки **OpenCV Mobile**, **TDL SDK**, которые при сборке линкуются динамически, поэтому для запуска примеров, необходимо, чтобы на плате были их корректные версии. При использовании некорректных библиотек адекватной работы не добиться: **TDL SDK** работает очень медленно, перестаёт обрабатывать модели для *cv181x*, детектирует > 2000 классов на одном изображении, а также может быть конфликт между **OpenCV Mobile** и **TDL SDK**.

Все необходимые библиотеки я собрал [здесь](https://drive.google.com/file/d/1nhWBeKPAJ9O-7zXrXu0uMwNdArOiBBLm/view?usp=drive_link). Данный архив надо скачать и распаковать на плате:

```bash
# На компьютере
scp required_libs.zip root@192.168.X.X:/root

# На плате
cd /root
unzip required_libs.zip
export LD_LIBRARY_PATH=/root/libs_patch/lib:/root/libs_patch/middleware_v2:/root/libs_patch/middleware_v2_3rd:/root/libs_patch/tpu_sdk_libs:/root/libs_patch:/root/libs_patch/opencv
```

Установку правильного значения **LD\_LIBRARY\_PATH** можно автоматизировать *(добавить export в конец файла /etc/profile)*:

```bash
echo "export LD_LIBRARY_PATH=/root/libs_patch/lib:/root/libs_patch/middleware_v2:/root/libs_patch/middleware_v2_3rd:/root/libs_patch/tpu_sdk_libs:/root/libs_patch:/root/libs_patch/opencv" | tee -a /etc/profile
```
